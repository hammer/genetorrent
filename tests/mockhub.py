#!/usr/bin/env python
#
# Copyright (c) 2012, Regents of the University of California
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL REGENTS OF THE UNIVERSITY OF CALIFORNIA BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

import sys
import tempfile
import os
import subprocess
import web
import time

from web.wsgiserver import CherryPyWSGIServer

from gtoinfo import encode_dict, decode
from utils.config import TestConfig

"""
MockHub is an extremely cooperative web service ala the
GeneTorrent executive.  It also provides basic BitTorrent
tracker functionality required to execute GeneTorrent
unit tests.
"""

# Path to CA cert generated by make-local rule
CERT_BASE = os.environ.get ('CERT_BASE', '')
CA_CERT = os.path.join (CERT_BASE, 'certs', 'cacert.pem')
CA_KEY  = os.path.join (CERT_BASE, 'certs', 'cakey.pem')

# peer ID '-GT' is client, '-Gt' is Server
GT_CLIENT_TAG = '-GT'
GT_SERVER_TAG = '-Gt'

TRACKER_ADDRESS = TestConfig.TRACKER_ADDRESS

class Analysis(object):
    """ An analysis object implements GTO download and GTO upload operations. """

    def POST(self, mode, name):
        user_data = web.input()

        # GTO request (URI download)
        if 'token' in  user_data and len(user_data) == 1:
            gto_file = os.path.join(
                'client',
                name,
                name + '.gto'
            )

            # open torrent file in binary mode on Windows
            torrent = open(gto_file, 'rb')
            try:
                torrent_data = torrent.read()
            finally:
                torrent.close()
            return torrent_data
        # Upload request
        # Add CA cert to GTO and set the tracker address
        if 'token' in user_data and 'file' in user_data and len(user_data) == 2:
            gtodict = decode(user_data.file)

            if (not 'nossl' in mode):
                cert_file = open(CA_CERT, 'r')
                try:
                    ca_cert_data = cert_file.read()
                finally:
                    cert_file.close()
                gtodict['info']['ssl-cert'] = ca_cert_data

            gtodict['announce'] = TRACKER_ADDRESS

            return encode_dict(gtodict)

class Session(object):
    """ A session object implements the security API for CSRs """

    def POST(self):
        """ Handles a CSR """
        user_data = web.input()

        # certificate signing request
        if 'token' in user_data and 'cert_req' in user_data and 'info_hash' in user_data:

            csr = user_data.cert_req
            csr_file = tempfile.NamedTemporaryFile(delete=False)
            csr_file.write(csr)
            csr_file.close()

            new_certificate_pem =  subprocess.Popen(['openssl', 'x509', '-req',
                '-days', '180', '-in', csr_file.name, '-CA', CA_CERT, '-CAkey',
                CA_KEY, '-CAcreateserial'], stdout=subprocess.PIPE).communicate()[0]

            os.unlink(csr_file.name)

            return new_certificate_pem

class Tracker(object):
    """ A simple GeneTorrent tracker for unit tests to use. """
    torrents = {}           # an infohash-indexed dict of peer lists
    torrents_completed = {} # an infohash-indexed dict of completed status

    def announce(self, user_data):
        infohash = user_data.info_hash
        ip = web.ctx.ip if not 'ip' in user_data else user_data.ip

        # add torrent to dicts, if new
        if not infohash in self.torrents:
            self.torrents[infohash] = []
            self.torrents_completed[infohash] = False

        # set completed flag when completed event arrives
        if 'event' in user_data and user_data.event == 'completed':
            self.torrents_completed[infohash] = True

        # TODO only remove peer-id
        #if 'event' in user_data and user_data.event == 'stopped':
        #    del self.torrents[infohash]

        # create a peer dict entry for requester
        # webpy is giving us unicode strings, so coerce into legacy strings
        peer_dict = {
            'peer id': str(user_data.peer_id),
            'ip': str(ip),
            'port': int(user_data.port),
        }

        # add peer dict entry to swarm dict, if it doesn't exist
        if not peer_dict in self.torrents[infohash]:
            self.torrents[infohash].append(peer_dict)

        # only give server peers to clients, and client peers to servers
        swarm = self.torrents[infohash]
        filtered_swarm = []

        # figure out which partition of the swarm to return (clients or servers)
        if GT_CLIENT_TAG in user_data.peer_id:
            # requester a client, only return servers
            filtered_swarm = [x for x in swarm if GT_SERVER_TAG in x['peer id']]
        else:
            # requester a server, only return clients
            filtered_swarm = [x for x in swarm if GT_CLIENT_TAG in x['peer id']]

        # assemble response dict
        response_dict = {'interval': 5, 'min interval': 5, 'peers': filtered_swarm}

        # bencode response
        return encode_dict(response_dict)

    def scrape(self, user_data):
        infohash = user_data.info_hash
        ip = web.ctx.ip

        # return state = 0 if the completed flag is set
        response_dict = {'files': {infohash: {'state': 0, 'complete': 0,
            'downloaded': 0, 'incomplete': 0}}}


        if infohash in self.torrents_completed and \
            self.torrents_completed[infohash]:
            response_dict = {'files': {infohash: {'state': 1, 'complete': 0,
            'downloaded': 0, 'incomplete': 0}}}

        return encode_dict(response_dict)

    def GET(self, name):
        """ Handles announce and scrape operations """
        user_data = web.input(_unicode=False)

        if 'announce' in name:
            return self.announce(user_data)
        elif 'scrape' in name:
            return self.scrape(user_data)
        else:
            web.notfound()

class Control:
    """ Provides a control interface for MockHub. """

    def POST(self):
        user_data = web.input()
        if 'exit' in user_data:
            exit(0)
        return "Running"

    def GET(self):
        user_data = web.input()
        if 'exit' in user_data:
            exit(0)
        return "Running"

class Credential:
    """ A test interface for downloading credentials. """
    def GET(self, name):
        name = name.replace('.key', '')
        name = name.replace('.pem', '')
        return name

# define URL processing/routes
urls = (
    '/cghub/data/(analysis)/download/(.+)', 'Analysis',
    '/cghub/data/(analysis)/upload/(.+)',   'Analysis',
    '/cghub/data/(analysis)/(.+)',          'Analysis',
    '/cghub/data/(analysis-nossl)/(.+)',    'Analysis',
    '/cghub/data/gtsession',                'Session',
    '/control',                             'Control',
    '/credential/(.+)',                     'Credential',
    '/(.+)',                                'Tracker',
)

app = web.application(urls, globals())

CherryPyWSGIServer.ssl_certificate = CA_CERT
CherryPyWSGIServer.ssl_private_key = CA_KEY

if __name__ == '__main__':
    app.run()


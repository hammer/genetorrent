#!/bin/sh
#
# LSB-ified SysV-style init script for the GeneTorrent servers
# Version 0.4.7.0; Copyright (c) 2011, Annai Systems, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of version 2.1 of the GNU Lesser General Public License
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it would be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# TODO List: 
# * change Required Start to include the gpfs service as a pre-requisite
# * move most parameter setting from here to a new GeneTorrent.conf file
# * fix GT to fork/exec as a daemon (detach from terminal) when a server
# * support multiple instances of the server per host (or have GT do it)
#
# For the curious, here's what those exit return codes mean:
# Code  Meaning
# 0	success
# 1	generic or unspecified error
# 2	invalid or excess arguments
# 3	unimplemented feature (e.g., "reload")
# 4	user had insufficient privileges
# 5	program is not installed
# 6	program is not configured
# 7	program is not running
#
# ...and here's what the status command return codes mean:
# Code  Meaning
# 0	program is running or service is OK
# 1	program is dead and /var/run pid file exists
# 2	program is dead and /var/lock lock file exists
# 3	program is not running
# 4	program or service status is unknown

# Now add something for chkconfig to chew on
#
# chkconfig:   345 22 02
# description: GeneTorrent server process
# processname: gtserver
# pidfile:     /var/run/GeneTorrent.pid
#
# IMPORTANT NOTES: 
# The LSB-style stanza below takes precedence over the chkconfig lines above 
# The (lowercase) pidfile def above needs to match the (uppercase) one below
#
### BEGIN INIT INFO
# Required-Start:    
# Should-Start:      $syslog $network
# Default-Start:     3 4 5
# Default-Stop:      0 1 2 6
# Short-Description: GeneTorrent parallel file transfer application server
# Description:       GeneTorrent is a high-speed file transfer application 
#                    that runs on a Linux cluster and moves huge data sets
#                    over the WAN efficiently, securely and reliably.
### END INIT INFO


# Utility functions go here:
#
# get_configvar() - Get the value of a configuration variable 
#                   from the GT config file
#
get_configvar() {
    var=$1
    config=$2

    grep "^${var}[     ]*=" $config | awk -F "=" '{print $2}' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

# Installation-specific variables go here:
#
# GT_BIN     - what command to execute to start GT
# GT_CONFIG  - where to find the GeneTorrent config file
# GT_USER    - who the GeneTorrent server runs as
# GT_ROOT    - where to find the GTO and data files
# GT_QUEUE   - location of the GeneTorrent download queue
#
GT_BIN=/usr/bin/gtserver
GT_CONFIG=/etc/gnos.d/GeneTorrent.conf
GT_STOP=/tmp/GeneTorrent.stop
GT_USER="gtorrent"

#
# Verify we have a configuration file
#
test -f $GT_CONFIG || exit 6

#
# Get some important data from the config file
#
GT_ROOT=$(get_configvar server $GT_CONFIG)
GT_QUEUE=$(get_configvar queue $GT_CONFIG)

#
# Uncomment the next line to get corefiles
export DAEMON_COREFILE_LIMIT="unlimited"

#
# Now assemble the vars into the GT command
#
GT_CMD="$GT_BIN --config-file=$GT_CONFIG &" 

# Validate some basic conditions

# Verify we have an executable
if [ "$1" = 'status' ]; then
    test -x $GT_BIN || exit 4
else
    test -x $GT_BIN || exit 5
fi

# Verify we have the root directory
if [ "$1" = 'status' ]; then
    test -d $GT_ROOT || exit 6
else
    test -d $GT_ROOT || exit 6
fi

# Verify we have a work queue
if [ "$1" = 'status' ]; then
    test -d $GT_QUEUE || exit 6
else
    test -d $GT_QUEUE || exit 6
fi

# Source function library.
. /etc/init.d/functions
. /etc/sysconfig/network

# The runtime-specific variables are here:
LOCKFILE=/var/lock/subsys/GeneTorrent
PIDFILE=/var/run/GeneTorrent.pid
RETVAL=0

base=`basename ${GT_BIN}`

start() {
    # This should have been cleaned up, but just in case
    rm -f ${GT_STOP}

    # Check that networking is configured.
    [ ${NETWORKING} = "no" ] && exit 1

    echo -n $"Starting GeneTorrent server... "
    daemon --pidfile=${PIDFILE} --user=${GT_USER} $GT_CMD
    RETVAL=$?
    echo

    # Now wait for the process to start so that we
    # can store the PID in the pidfile
    gt_pid=
    retry=3
    while [ "$retry" -gt 0 ]; do
        gt_pid=`pidof $base`
        [ $? -eq 0 ] && break
        retry=$(($retry -1))
        sleep 1
    done

    if [ -z "$gt_pid" ]; then
        RETVAL=3
    else
        echo $gt_pid > ${PIDFILE} 2> /dev/null
    fi

    [ $RETVAL -eq 0 ] && touch ${LOCKFILE} 
    return $RETVAL
}

stop() {
    echo -n $"Stopping GeneTorrent server... "

    retry=20
    gt_pid=`pidofproc -p ${PIDFILE} $base`
    RETVAL=

    if [ -n "$gt_pid" ]; then
        # We found the pid for our process, so attempt to 
        # perform graceful exit
        touch ${GT_STOP}

        # Now, give the process some time to exit cleanly
        while [ "$retry" -gt 0 ]; do
            checkpid $gt_pid 2>&1
            if [ $? -eq 1 ]; then
                # No longer running
                RETVAL=0
                success $"$base shutdown"
                rm -f ${PIDFILE}
                break
            fi
            # Process is still there.  Keep waiting.
            retry=$(($retry -1))
            sleep 1
        done
    fi

    if [ -z "$RETVAL" ]; then
        # Graceful exit didn't seem to happen.  Use the
        # big hammer.
        killproc -p ${PIDFILE} $GT_BIN
        RETVAL=$?
    fi
	
    rm -f ${GT_STOP}
    [ $RETVAL -eq 0 ] && rm -f ${LOCKFILE} ${PIDFILE}
    echo
    return $RETVAL
}

reload() {
        echo -n $"GeneTorrent reload not implemented... "
        killproc -p ${PIDFILE} $GT_BIN -HUP
	RETVAL=$?
	echo
	return $RETVAL
}

restart() {
	stop
	start
}

RETVAL=0

# See how we were called.
case "$1" in
  start)
	start
	;;
  stop)
	stop
	;;
  status)
	status -p ${PIDFILE} $GT_BIN
        RETVAL=$?
	;;
  restart)
	restart
	;;
  reload)
        reload
	;;
  condrestart)
  	if [ -f $LOCKFILE ]; then
		restart
	fi
	;;
  *)
	echo $"Usage: $0 {start|stop|status|restart|condrestart}"
	exit 2
        ;;
esac

exit $RETVAL
